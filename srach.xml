<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构之动态数组]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组数组的特点优点： 按照索引查询数据元素速度快 能存储大量数据 按照索引遍历数组方便 缺点： 根据内容查找元素速度慢 数组的大小一经确定不能改变（数组的局限性） 数组只能存储一种类型的数据 增加，删除元素效率慢 未封装任何方法，所有操作都需要用户自己定义 12345678910111213141516171819202122232425262728293031public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 动态数组使得数组的容量是可以伸缩的。 实现动态数组的思路 定义一个新的容量newCapacity，以新容量开辟一个新数组newData 遍历原数组data的元素，赋值到新数组newData中 将原数组的指针指向新数组 12345678// 将数组空间的容量变成newCapacity大小private void resize(int newCapacity)&#123;E[] newData = (E[])new Object[newCapacity];for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData;&#125; 动态数组的常见操作添加元素操作1234567891011121314151617181920212223242526// 在index索引的位置插入一个新元素epublic void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length);//扩充数组的容量 for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++;&#125;// 向所有元素后添加一个新元素public void addLast(E e)&#123; add(size, e);&#125;// 在所有元素前添加一个新元素public void addFirst(E e)&#123; add(0, e);&#125; 删除元素操作1234567891011121314151617181920212223242526272829303132// 从数组中删除index位置的元素, 返回删除的元素public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0)//为何要如此判断，下面有分析 resize(data.length / 2); return ret;&#125;// 从数组中删除第一个元素, 返回删除的元素public E removeFirst()&#123; return remove(0);&#125;// 从数组中删除最后一个元素, 返回删除的元素public E removeLast()&#123; return remove(size - 1);&#125;// 从数组中删除元素epublic void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index);&#125; 更改元素操作123456// 修改index索引位置的元素为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e;&#125; 查询元素操作123456789101112131415161718192021222324// 获取index索引位置的元素public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index];&#125;// 查找数组中是否有元素epublic boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false;&#125;// 查找数组中元素e所在的索引，如果不存在元素e，则返回-1public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1;&#125; 动态数组时间复杂度分析添加元素操作：O(n) addLast(e)：O(1) addFirst(e)：O(n) add(index,e)：O(n/2) 删除元素操作：O(n) removeLast(e)：O(1) removeFirst(e)：O(n) remove(index,e)：O(n/2) 修改元素操作：已知索引：O(1)；未知索引：O(n) set(index,e)：O(1) 查找元素操作：已知索引O(1)；未知索引O(n) get(index)：O(1) contains(e):：O(n) find(e)：O(n) resize()时间复杂度分析 resize()：O(n) 从均摊复杂度的角度看addLast操作和removeLast操作 假设capacity=n，n+1次addLast，触发resize，而resize操作了n次，所以总共进行2n+1次基本操作，使用均摊复杂度均摊计算，每次addLast操作，进行2次基本操作，时间复杂度为O(1)。同理，我们看removeLast操作，均摊复杂度后的时间复杂度也为O(1). 防止复杂度震荡 出现复杂度震荡的问题描述： 假设现在我们有一个数组，容量是n，并且装满了元素。这时候，我想添加一个元素，显然是需要进行扩容，容量变为2n，耗时O(n)的时间。但是此时，我又删除了一个元素触发了缩容操作，耗时O(n)的时间。当我们每次触发缩容或扩容操作，都会耗费O(n)额复杂度，那么这便是复杂度的震荡。 分析原因：在特殊情况下，我们频繁的添加和删减操作，导致过于着急的去扩容或缩容。 解决方案： 可以采用一种相对懒惰(Lazy机制)的策略。 比如说，一个满的数组，容量n，添加元素需要进行扩容，容量变为2n。但在这时，在进行删除元素后，不立即进行缩容操作，而是再等等。如果后面一直有删除操作的话，删除到整个数组容积的1/4，再触发缩容操作。缩容数组的1/2，而不是直接缩容到1/4。此时，数组中存在1/4的元素，还预留了1/4的空间。通过这样的策略，防止了复杂度的震荡，从而有效的提升整体的性能。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>动态数组</tag>
        <tag>java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
