<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构之并查集]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[什么是并查集在计算机科学中，并查集是一种树形的数据结构，用于处理一些不交集的合并及查询问题。有一个联合-查找算法定义了两个用于此数据结构的操作。 123456789//并查集接口public interface UF &#123; int getSize(); //判断两个元素p,q是否连接在一起，及判断它们是否属于同一个集合 boolean isConnected(int p, int q); //将两个元素合并在一起成为一个集合（即将这两个子集合并成同一个集合） void unionElements(int p, int q);&#125; 什么是并查集森林是一种将每一个集合以树表示的数据结构，其中每一个节点都保存着它父节点的引用（孩子节点指向父节点）。 在并查集森林中，每个集合的代表即是集合的根节点。“查找”根据其父节点的引用向根进行直到根节点。“联合”就是将两棵树合并到一起。这通过将一棵树的根连接到另一棵树的根。 并查集的实现quick find思想：并查集查询的操作快，合并比较慢。 思路：通过一个数组来实现一个并查集，数组索引作为数据编号 从上面的图可以知道：0，2，4，6，8 属于一个集合；1，3，5，7，9属于另一个集合。元素4 和元素5不属于同一个集合，因为它们所对应的编号不一样。元素4对应的是编号0，元素5对应的是编号1。 如果要合并两个集合(union(4,5))，因为 4 和 5 是属于两个不同的集合。合并后，以前分别和元素 4连接的元素与元素5连接的元素，也都连接起来了： 根据上面的描述得知，基于上面实现方案的并查集，查询操作的时间复杂度为 O(1)，合并操作的时间复杂度为 O(n)。 具体代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 我们的第一版Union-Findpublic class UnionFind1 implements UF &#123; private int[] id; // 我们的第一版Union-Find本质就是一个数组 public UnionFind1(int size) &#123; id = new int[size]; // 初始化, 每一个id[i]指向自己, 没有合并的元素 for (int i = 0; i &lt; size; i++) id[i] = i; &#125; @Override public int getSize()&#123; return id.length; &#125; // 查找元素p所对应的集合编号 // O(1)复杂度 private int find(int p) &#123; if(p &lt; 0 || p &gt;= id.length) throw new IllegalArgumentException("p is out of bound."); return id[p]; &#125; // 查看元素p和元素q是否所属一个集合 // O(1)复杂度 @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; // 合并元素p和元素q所属的集合 // O(n) 复杂度 @Override public void unionElements(int p, int q) &#123; int pID = find(p); int qID = find(q); if (pID == qID) return; // 合并过程需要遍历一遍所有元素, 将两个元素的所属集合编号合并 for (int i = 0; i &lt; id.length; i++) if (id[i] == pID) id[i] = qID; &#125;&#125; quick union通过树形结构来描述节点之间的关系，底层存储通过数组来存储。 以前我们介绍到树都是父节点指向子节点的，这里我们是通过子节点来指向父节点，根节点指向它自己。 数组索引用来表示元素编号，存储的是元素编号对应的父节点编号。如下图所示： 从上图可以看出，每个节点的父节点编号都是它自己，说明每个节点都是一个根节点，那么这个数组就表示一个森林。 合并 4、3， 合并6 和 5，就变成： 合并4，8，再合并9，4，就变成： 从上面的分析，合并和查找操作的时间复杂度为 O(h)，h就是树的高度。 相对 Quick Find 实现的并查集 Quick Union 实现的并查集牺牲了一点查找的性能，提高了合并的性能。 具体代码的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 我们的第二版Union-Findpublic class UnionFind2 implements UF &#123; // 我们的第二版Union-Find, 使用一个数组构建一棵指向父节点的树 // parent[i]表示第一个元素所指向的父节点 private int[] parent; // 构造函数 public UnionFind2(int size)&#123; parent = new int[size]; // 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 for( int i = 0 ; i &lt; size ; i ++ ) parent[i] = i; &#125; @Override public int getSize()&#123; return parent.length; &#125; // 查找过程, 查找元素p所对应的集合编号 // O(h)复杂度, h为树的高度 private int find(int p)&#123; if(p &lt; 0 || p &gt;= parent.length) throw new IllegalArgumentException("p is out of bound."); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while(p != parent[p]) p = parent[p]; return p; &#125; // 查看元素p和元素q是否所属一个集合 // O(h)复杂度, h为树的高度 @Override public boolean isConnected( int p , int q )&#123; return find(p) == find(q); &#125; // 合并元素p和元素q所属的集合 // O(h)复杂度, h为树的高度 @Override public void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; parent[pRoot] = qRoot; &#125;&#125; 并查集的优化基于size的优化上面Quick Union版本的并查集基于树形结构实现的，但是没有对树的高度进行任何优化和限制。 所以基于size优化的思路就是：节点个数少的往节点个数多的树去合并。 具体代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 我们的第三版Union-Findpublic class UnionFind3 implements UF&#123; private int[] parent; // parent[i]表示第一个元素所指向的父节点 private int[] sz; // sz[i]表示以i为根的集合中元素个数 // 构造函数 public UnionFind3(int size)&#123; parent = new int[size]; sz = new int[size]; // 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 for(int i = 0 ; i &lt; size ; i ++)&#123; parent[i] = i; sz[i] = 1; &#125; &#125; //其他方法跟第二版的一样，未改动 // 合并元素p和元素q所属的集合 // O(h)复杂度, h为树的高度 @Override public void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot) return; // 根据两个元素所在树的元素个数不同判断合并方向 // 将元素个数少的集合合并到元素个数多的集合上 if(sz[pRoot] &lt; sz[qRoot])&#123; parent[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; &#125; else&#123; // sz[qRoot] &lt;= sz[pRoot] parent[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; &#125; &#125;&#125; 基于rank的优化思路：rank代表树的高度或深度。高度低的树向高度高的树合并。 具体代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 我们的第四版Union-Findpublic class UnionFind4 implements UF &#123; private int[] rank; // rank[i]表示以i为根的集合所表示的树的层数 private int[] parent; // parent[i]表示第i个元素所指向的父节点 // 构造函数 public UnionFind4(int size)&#123; rank = new int[size]; parent = new int[size]; // 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 for( int i = 0 ; i &lt; size ; i ++ )&#123; parent[i] = i; rank[i] = 1; &#125; &#125; //其他方法的代码跟第二版的一样，未改动 // 合并元素p和元素q所属的集合 // O(h)复杂度, h为树的高度 @Override public void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; // 根据两个元素所在树的rank不同判断合并方向 // 将rank低的集合合并到rank高的集合上 if(rank[pRoot] &lt; rank[qRoot]) parent[pRoot] = qRoot; else if(rank[qRoot] &lt; rank[pRoot]) parent[qRoot] = pRoot; else&#123; // rank[pRoot] == rank[qRoot] parent[pRoot] = qRoot; rank[qRoot] += 1; // 此时, 我维护rank的值 &#125; &#125;&#125; 路径压缩优化路径压缩基于rank的基础上来做优化的。优化时机是在执行 find操作 的时候对其进行路径压缩。 思路：parent[p] = parent[parent[p]] 非递归的路径压缩优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 我们的第五版Union-Findpublic class UnionFind5 implements UF &#123; // rank[i]表示以i为根的集合所表示的树的层数 // 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值 // 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准 private int[] rank; private int[] parent; // parent[i]表示第i个元素所指向的父节点 // 构造函数 public UnionFind5(int size)&#123; rank = new int[size]; parent = new int[size]; // 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 for( int i = 0 ; i &lt; size ; i ++ )&#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize()&#123; return parent.length; &#125; // 查找过程, 查找元素p所对应的集合编号 // O(h)复杂度, h为树的高度 private int find(int p)&#123; if(p &lt; 0 || p &gt;= parent.length) throw new IllegalArgumentException("p is out of bound."); while( p != parent[p] )&#123; parent[p] = parent[parent[p]]; p = parent[p]; &#125; return p; &#125; // 查看元素p和元素q是否所属一个集合 // O(h)复杂度, h为树的高度 @Override public boolean isConnected( int p , int q )&#123; return find(p) == find(q); &#125; // 合并元素p和元素q所属的集合 // O(h)复杂度, h为树的高度 @Override public void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; // 根据两个元素所在树的rank不同判断合并方向 // 将rank低的集合合并到rank高的集合上 if( rank[pRoot] &lt; rank[qRoot] ) parent[pRoot] = qRoot; else if( rank[qRoot] &lt; rank[pRoot]) parent[qRoot] = pRoot; else&#123; // rank[pRoot] == rank[qRoot] parent[pRoot] = qRoot; rank[qRoot] += 1; // 此时, 我维护rank的值 &#125; &#125;&#125; 递归的路径压缩优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 我们的第六版Union-Findpublic class UnionFind6 implements UF &#123; // rank[i]表示以i为根的集合所表示的树的层数 // 在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值 // 这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准 private int[] rank; private int[] parent; // parent[i]表示第i个元素所指向的父节点 // 构造函数 public UnionFind6(int size)&#123; rank = new int[size]; parent = new int[size]; // 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 for( int i = 0 ; i &lt; size ; i ++ )&#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize()&#123; return parent.length; &#125; // 查找过程, 查找元素p所对应的集合编号 // O(h)复杂度, h为树的高度 private int find(int p)&#123; if(p &lt; 0 || p &gt;= parent.length) throw new IllegalArgumentException("p is out of bound."); // path compression 2, 递归算法 if(p != parent[p]) parent[p] = find(parent[p]); return parent[p]; &#125; // 查看元素p和元素q是否所属一个集合 // O(h)复杂度, h为树的高度 @Override public boolean isConnected( int p , int q )&#123; return find(p) == find(q); &#125; // 合并元素p和元素q所属的集合 // O(h)复杂度, h为树的高度 @Override public void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; // 根据两个元素所在树的rank不同判断合并方向 // 将rank低的集合合并到rank高的集合上 if( rank[pRoot] &lt; rank[qRoot] ) parent[pRoot] = qRoot; else if( rank[qRoot] &lt; rank[pRoot]) parent[qRoot] = pRoot; else&#123; // rank[pRoot] == rank[qRoot] parent[pRoot] = qRoot; rank[qRoot] += 1; // 此时, 我维护rank的值 &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之二叉堆]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E5%A0%86%2F</url>
    <content type="text"><![CDATA[什么是二叉堆二叉堆是一种特殊的堆，二叉堆具有堆的性质（父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值），二叉堆又具有二叉树的性质（二叉堆是完全二叉树或者是近似完全二叉树）。当父节点的键值大于或等于（小于或等于）它的每一个子节点的键值时我们称它为最大堆（最小堆）。 完全二叉树：简单理解就是把元素顺序排列成树的形状。 二叉堆底层实现二叉堆多数是以数组作为它们底层元素的存储。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; public MaxHeap(int capacity)&#123; data = new Array&lt;&gt;(capacity); &#125; public MaxHeap()&#123; data = new Array&lt;&gt;(); &#125; public MaxHeap(E[] arr)&#123; data = new Array&lt;&gt;(arr); for(int i = parent(arr.length - 1) ; i &gt;= 0 ; i --) siftDown(i); &#125; // 返回堆中的元素个数 public int size()&#123; return data.getSize(); &#125; // 返回一个布尔值, 表示堆中是否为空 public boolean isEmpty()&#123; return data.isEmpty(); &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引 private int parent(int index)&#123; if(index == 0) throw new IllegalArgumentException("index-0 doesn't have parent."); return (index - 1) / 2; &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index)&#123; return index * 2 + 1; &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index)&#123; return index * 2 + 2; &#125; // 向堆中添加元素 public void add(E e)&#123; data.addLast(e); siftUp(data.getSize() - 1); &#125; //节点上浮操作 private void siftUp(int k)&#123; while(k &gt; 0 &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; 0 )&#123; data.swap(k, parent(k)); k = parent(k); &#125; &#125; // 看堆中的最大元素 public E findMax()&#123; if(data.getSize() == 0) throw new IllegalArgumentException("Can not findMax when heap is empty."); return data.get(0); &#125; // 取出堆中最大元素 public E extractMax()&#123; E ret = findMax(); data.swap(0, data.getSize() - 1); data.removeLast(); siftDown(0); return ret; &#125; //节点下沉操作 private void siftDown(int k)&#123; while(leftChild(k) &lt; data.getSize())&#123; int j = leftChild(k); // 在此轮循环中,data[k]和data[j]交换位置 if( j + 1 &lt; data.getSize() &amp;&amp; data.get(j + 1).compareTo(data.get(j)) &gt; 0 ) j ++; // data[j] 是 leftChild 和 rightChild 中的最大值 if(data.get(k).compareTo(data.get(j)) &gt;= 0 ) break; data.swap(k, j); k = j; &#125; &#125; // 取出堆中的最大元素，并且替换成元素e public E replace(E e)&#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之队列]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列什么是队列队列也是一种线性结构。相比数组，队列对应的操作是数组的子集。只能从一端（队尾）添加元素，只能从另一端（队头）取出元素。是一种先进先出的数据结构。 队列底层的实现队列底层的实现可以是动态数组和链表。 队列常见的一些方法12345678public interface Queue&lt;E&gt; &#123; int getSize(); boolean isEmpty(); void enqueue(E e); E dequeue(); E getFront();&#125; 动态数组实现的队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; //Array代码可以观看我之前写过的动态数组代码或者可以用java的集合类ArrayList private Array&lt;E&gt; array; public ArrayQueue(int capacity)&#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayQueue()&#123; array = new Array&lt;&gt;(); &#125; @Override public int getSize()&#123; return array.getSize(); &#125; @Override public boolean isEmpty()&#123; return array.isEmpty(); &#125; public int getCapacity()&#123; return array.getCapacity(); &#125; @Override public void enqueue(E e)&#123; array.addLast(e); &#125; @Override public E dequeue()&#123; return array.removeFirst(); &#125; @Override public E getFront()&#123; return array.getFirst(); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append("Queue: "); res.append("front ["); for(int i = 0 ; i &lt; array.getSize() ; i ++)&#123; res.append(array.get(i)); if(i != array.getSize() - 1) res.append(", "); &#125; res.append("] tail"); return res.toString(); &#125; 动态数组Array的具体代码可以观看我之前写过的动态数组代码：数据结构之动态数组 动态数组实现的队列时间复杂度分析：除了出队时间复杂度是O(n)，其他操作是O(1) 链表实现的队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private class Node&#123; public E e; public Node next; public Node(E e, Node next)&#123; this.e = e; this.next = next; &#125; public Node(E e)&#123; this(e, null); &#125; public Node()&#123; this(null, null); &#125; @Override public String toString()&#123; return e.toString(); &#125; &#125; private Node head, tail; private int size; public LinkedListQueue()&#123; head = null; tail = null; size = 0; &#125; @Override public int getSize()&#123; return size; &#125; @Override public boolean isEmpty()&#123; return size == 0; &#125; @Override public void enqueue(E e)&#123; if(tail == null)&#123; tail = new Node(e); head = tail; &#125; else&#123; tail.next = new Node(e); tail = tail.next; &#125; size ++; &#125; @Override public E dequeue()&#123; if(isEmpty()) throw new IllegalArgumentException("Cannot dequeue from an empty queue."); Node retNode = head; head = head.next; retNode.next = null; if(head == null) tail = null; size --; return retNode.e; &#125; @Override public E getFront()&#123; if(isEmpty()) throw new IllegalArgumentException("Queue is empty."); return head.e; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append("Queue: front "); Node cur = head; while(cur != null) &#123; res.append(cur + "-&gt;"); cur = cur.next; &#125; res.append("NULL tail"); return res.toString(); &#125;&#125; 用上述链表的形式实现的队列的方法时间复杂度都为O(1)。原因是添加了一个指向链表尾部的指针，用来解决入队的时间复杂度，把原为O(n)变为O(1)。 循环队列用来解决动态数组实现的队列出队的时间复杂度问题。 两个判断条件要弄清楚： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private E[] data; private int front, tail; private int size; public LoopQueue(int capacity)&#123; data = (E[])new Object[capacity + 1]; front = 0; tail = 0; size = 0; &#125; public LoopQueue()&#123; this(10); &#125; public int getCapacity()&#123; return data.length - 1; &#125; @Override public boolean isEmpty()&#123; return front == tail; &#125; @Override public int getSize()&#123; return size; &#125; @Override public void enqueue(E e)&#123; if((tail + 1) % data.length == front) resize(getCapacity() * 2); data[tail] = e; tail = (tail + 1) % data.length; size ++; &#125; @Override public E dequeue()&#123; if(isEmpty()) throw new IllegalArgumentException("Cannot dequeue from an empty queue."); E ret = data[front]; data[front] = null; front = (front + 1) % data.length; size --; if(size == getCapacity() / 4 &amp;&amp; getCapacity() / 2 != 0) resize(getCapacity() / 2); return ret; &#125; @Override public E getFront()&#123; if(isEmpty()) throw new IllegalArgumentException("Queue is empty."); return data[front]; &#125; private void resize(int newCapacity)&#123; E[] newData = (E[])new Object[newCapacity + 1]; for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[(i + front) % data.length]; data = newData; front = 0; tail = size; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Queue: size = %d , capacity = %d\n", size, getCapacity())); res.append("front ["); for(int i = front ; i != tail ; i = (i + 1) % data.length)&#123; res.append(data[i]); if((i + 1) % data.length != tail) res.append(", "); &#125; res.append("] tail"); return res.toString(); &#125;&#125; 循环队列的时间复杂度分析：采用均摊复杂度，我们可以发现出队和入队的时间复杂度都为O(1)。所以循环队列的相关操作的时间复杂度都为O(1)。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之栈]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈什么是栈栈是一种特殊的线性表，仅允许在表的一端进行插入和删除运算。这一端被称为栈顶（top），相对地，把另一端称为栈底（bottom）。向一个栈插入新元素又称作进栈、入栈或压栈（push），它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈（pop），它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。所以栈具有“后入先出”的特点（LIFO）。 栈底层的实现栈的底层实现可以是动态数组和链表 栈常见的一些方法12345678public interface Stack&lt;E&gt; &#123; int getSize(); boolean isEmpty(); void push(E e); E pop(); E peek();&#125; 动态数组实现的栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArrayStack(int capacity)&#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayStack()&#123; array = new Array&lt;&gt;(); &#125; @Override public int getSize()&#123; return array.getSize(); &#125; @Override public boolean isEmpty()&#123; return array.isEmpty(); &#125; public int getCapacity()&#123; return array.getCapacity(); &#125; @Override public void push(E e)&#123; array.addLast(e); &#125; @Override public E pop()&#123; return array.removeLast(); &#125; @Override public E peek()&#123; return array.getLast(); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append("Stack: "); res.append('['); for(int i = 0 ; i &lt; array.getSize() ; i ++)&#123; res.append(array.get(i)); if(i != array.getSize() - 1) res.append(", "); &#125; res.append("] top"); return res.toString(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//动态数组的实现public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125; // 在index索引的位置插入一个新元素e public void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length); for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++; &#125; // 向所有元素后添加一个新元素 public void addLast(E e)&#123; add(size, e); &#125; // 在所有元素前添加一个新元素 public void addFirst(E e)&#123; add(0, e); &#125; // 获取index索引位置的元素 public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index]; &#125; public E getLast()&#123; return get(size - 1); &#125; public E getFirst()&#123; return get(0); &#125; // 修改index索引位置的元素为e public void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e; &#125; // 查找数组中是否有元素e public boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false; &#125; // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1 public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1; &#125; // 从数组中删除index位置的元素, 返回删除的元素 public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0) resize(data.length / 2); return ret; &#125; // 从数组中删除第一个元素, 返回删除的元素 public E removeFirst()&#123; return remove(0); &#125; // 从数组中删除最后一个元素, 返回删除的元素 public E removeLast()&#123; return remove(size - 1); &#125; // 从数组中删除元素e public void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d , capacity = %d\n", size, data.length)); res.append('['); for(int i = 0 ; i &lt; size ; i ++)&#123; res.append(data[i]); if(i != size - 1) res.append(", "); &#125; res.append(']'); return res.toString(); &#125; // 将数组空间的容量变成newCapacity大小 private void resize(int newCapacity)&#123; E[] newData = (E[])new Object[newCapacity]; for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData; &#125;&#125; 栈应用的一些场景编辑器的撤销操作 系统调用栈 编译器的括号匹配 如下题： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean isValid(String s) &#123; ArrayStack&lt;Character&gt; stack = new ArrayStack&lt;&gt;(); for(int i = 0 ; i &lt; s.length() ; i ++)&#123; char c = s.charAt(i); if(c == '(' || c == '[' || c == '&#123;') stack.push(c); else&#123; if(stack.isEmpty()) return false; char topChar = stack.pop(); if(c == ')' &amp;&amp; topChar != '(') return false; if(c == ']' &amp;&amp; topChar != '[') return false; if(c == '&#125;' &amp;&amp; topChar != '&#123;') return false; &#125; &#125; return stack.isEmpty(); &#125; public static void main(String[] args) &#123; System.out.println((new Solution()).isValid("()[]&#123;&#125;")); System.out.println((new Solution()).isValid("([)]")); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之二分搜索树]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[为什么要有树结构树结构本身是一种天然的组织结构。将数据使用数结构存储后，会很高效 二叉树特性： 二叉树和链表一样，是动态数据结构。 二叉树具有唯一根节点。每个节点最多有两个孩子，最多有一个父亲。 二叉树具有天然的递归结构。 满二叉树：在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层上。这样的二叉树称作满二叉树。 完全二叉树：如果一个具有n个节点的二叉树与满二叉树的前n个节点的结构相同，这样的二叉树被称为完全二叉树。 12345class Node&#123; E e; Node left;//左孩子 Node right;//右孩子&#125; 二分搜索树BST特性1）二分搜索树每个节点的值：大于左子树的所有节点的值；小于其右子树节点的值。 2）每一棵子树也是二分搜索树 3)）存储的元素必须有可比性 12345678910111213141516171819202122232425262728//实现Compareble接口是为了让存储的元素具有可比性public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; //成员内部类 private class Node &#123; public E e; public Node left, right; public Node(E e) &#123;//Node类初始化 this.e = e; left = null; right = null; &#125; &#125; //成员变量 private Node root; //根节点 private int size; //元素个数 public BST()&#123; //BST初始化 root = null; size = 0; &#125; //返回元素个数 public int size()&#123; return size; &#125; //判断BST是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 添加新元素代码讲解的是不包含重复元素和采用递归的写法。 如果想包含重复元素，只需定义左子树小于等于节点，或右子树大于等于节点。二分搜索树添加元素的非递归写法和链表很像。 思想：从根节点开始找插入的位置，满足二叉搜索树的特性，比左子节点大，比右子节点小。 步骤： 从根节点开始，先比较当前节点，如果当前节点为null那么很明显就应该插入到这个节点。 如果上面的节点不是null，那么和当前节点比较，如果小于节点就往左子树放，如果大于节点就往右子树放。 然后分别对左子树或者右子树递归的递归进行如上1、2步骤的操作。 123456789101112131415161718192021222324252627282930// 向二分搜索树中添加新的元素epublic void add(E e)&#123; if(root == null)&#123; root = new Node(e); size ++; &#125; else add(root, e);&#125;// 向以node为根的二分搜索树中插入元素e，递归算法private void add(Node node, E e)&#123; //求解最基本问题 if(e.equals(node.e)) return; else if(e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null)&#123; node.left = new Node(e); size ++; return; &#125; else if(e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null)&#123; node.right = new Node(e); size ++; return; &#125; //把原问题转化为更小的问题 if(e.compareTo(node.e) &lt; 0) add(node.left, e); else //e.compareTo(node.e) &gt; 0 add(node.right, e);&#125; 添加元素java代码改进版： 1234567891011121314151617181920// 向二分搜索树中添加新的元素epublic void add(E e)&#123; root = add(root, e);&#125;// 向以node为根的二分搜索树中插入元素e，递归算法// 返回插入新节点后二分搜索树的根private Node add(Node node, E e)&#123; //求解最基本问题 if(node == null)&#123; size ++; return new Node(e); &#125; //把原问题转化为更小的问题 if(e.compareTo(node.e) &lt; 0) node.left = add(node.left, e); else if(e.compareTo(node.e) &gt; 0) node.right = add(node.right, e); return node;&#125; 查询元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 看二分搜索树中是否包含元素epublic boolean contains(E e)&#123; return contains(root, e);&#125;// 看以node为根的二分搜索树中是否包含元素e, 递归算法private boolean contains(Node node, E e)&#123; //求解最基本问题 if(node == null) return false; //把原问题转化为更小的问题 if(e.compareTo(node.e) == 0) return true; else if(e.compareTo(node.e) &lt; 0) return contains(node.left, e); else // e.compareTo(node.e) &gt; 0 return contains(node.right, e);&#125;// 寻找二分搜索树的最小元素public E minimum()&#123; if(size == 0) throw new IllegalArgumentException("BST is empty!"); return minimum(root).e;&#125;// 返回以node为根的二分搜索树的最小值所在的节点private Node minimum(Node node)&#123; if(node.left == null) return node; return minimum(node.left);&#125;// 寻找二分搜索树的最大元素public E maximum()&#123; if(size == 0) throw new IllegalArgumentException("BST is empty"); return maximum(root).e;&#125;// 返回以node为根的二分搜索树的最大值所在的节点private Node maximum(Node node)&#123; if(node.right == null) return node; return maximum(node.right);&#125; 遍历遍历操作就是把所有节点都访问一遍(访问的原因和业务有关)，在线性结构下，遍历是极其简单的（for循环）。 树结构的遍历操作，两棵子树都要顾及。 前序遍历：若二叉树为空，则算法结束，否则：1）访问根节点。2）前序遍历根节点的左子树。3）前序遍历根节点的右子树。 1234567891011121314// 二分搜索树的前序遍历public void preOrder()&#123; preOrder(root);&#125;// 前序遍历以node为根的二分搜索树, 递归算法private void preOrder(Node node)&#123; if(node == null) return; System.out.println(node.e); preOrder(node.left); preOrder(node.right);&#125; 非递归的二叉树前序遍历算法 借助栈的数据结构来实现，步骤如下： 1）把根节点入栈 2）只要栈不为空，就依次把每个节点出栈 若该节点的右子树非空，将该右子树的根节点入栈 若该节点的左子树非空，将该左子树的根节点入栈 123456789101112131415// 二分搜索树的非递归前序遍历public void preOrderNR()&#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; Node cur = stack.pop(); System.out.println(cur.e); if(cur.right != null) stack.push(cur.right); if(cur.left != null) stack.push(cur.left); &#125;&#125; 中序遍历若二叉树为空，则算法结束，否则：1）中序遍历根节点的左子树。2）访问根节点。3）中序遍历根节点的右子树。 123456789101112// 二分搜索树的中序遍历public void inOrder()&#123; inOrder(root);&#125;// 中序遍历以node为根的二分搜索树, 递归算法private void inOrder(Node node)&#123; if(node == null) return; inOrder(node.left); System.out.println(node.e); inOrder(node.right);&#125; 后序遍历若二叉树为空，则算法结束，否则：1）后序遍历根节点的左子树。2）后序遍历根节点的右子树。3）访问根节点。 123456789101112// 二分搜索树的后序遍历public void postOrder()&#123; postOrder(root);&#125;// 后序遍历以node为根的二分搜索树, 递归算法private void postOrder(Node node)&#123; if(node == null) return; postOrder(node.left); postOrder(node.right); System.out.println(node.e);&#125; 层序遍历(广度优先遍历)利用队列的数据结构实现，步骤如下： 1）将根节点入队列 2）当队列不为空时，依次把队列中的节点出队列 若该节点的左子树不为空，将该左子树的根节点入队列 若该节点的右子树不为空，将该右子树的根节点入队列 123456789101112131415//二分搜索树的层序遍历public void leveOrder()&#123; if(root == null) return; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty())&#123; Node cur = q.remove(); System.out.println(cur.e); if(cur.left!= null) q.add(cur.left); if(cur.right!=null) q.add(cur.right); &#125;&#125; 删除元素删除最小值所在节点思想：根据二分搜索树的特性，我们知道节点的左孩子小于该节点（依次递归，找到最小值) 12345678910111213141516171819202122// 从二分搜索树中删除最小值所在节点, 返回最小值public E removeMin()&#123; //寻找到二分搜索树中最小的元素 E ret = minimum(); root = removeMin(root); return ret;&#125;// 删除掉以node为根的二分搜索树中的最小节点// 返回删除节点后新的二分搜索树的根private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node;&#125; 删除最大值所在节点思想：根据二分搜索树的特性，我们知道节点的右孩子大于该节点（依次递归，找到最大值) 123456789101112131415161718192021// 从二分搜索树中删除最大值所在节点public E removeMax()&#123; E ret = maximum(); root = removeMax(root); return ret;&#125;// 删除掉以node为根的二分搜索树中的最大节点// 返回删除节点后新的二分搜索树的根private Node removeMax(Node node)&#123; if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; node.right = removeMax(node.right); return node;&#125; 删除元素为e的节点分为三种情况 1）待删除元素的节点左子树为空 2）待删除元素的节点右子树为空 3）待删除元素的节点左右子树非空情况 找到待删除节点的后继节点来代替 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; 找到待删除节点的前驱节点来代替 Node precursor = maximum(node.left); precursor.left = removeMax(node.left); precursor.right = node.left; node.left = node.right = null; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 从二分搜索树中删除元素为e的节点public void remove(E e)&#123; root = remove(root, e);&#125;// 删除掉以node为根的二分搜索树中值为e的节点, 递归算法// 返回删除节点后新的二分搜索树的根private Node remove(Node node, E e)&#123; if( node == null ) return null; if( e.compareTo(node.e) &lt; 0 )&#123; node.left = remove(node.left , e); return node; &#125; else if(e.compareTo(node.e) &gt; 0 )&#123; node.right = remove(node.right, e); return node; &#125; else&#123; // e.compareTo(node.e) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125;&#125; 二分搜索树的时间复杂度分析 添加操作：add(E e)：O(logn) 删除操作：remove(E e)：O(logn) 查询操作：contains(E e)：O(logn) 二分搜索树的顺序性二分搜索树当做查找表的一种实现。我们使用二分搜索树的目的是通过查找 key 马上得到 value。 二分搜索树还能回答哪些问题呢？这些问题都和顺序相关。 minimum，maximum successor，predecessor（这两个元素在二分搜索树的 key 中必须存在） floor（地板），ceil（天花板）（这两个元素在二分搜索树的 key 中可以存在，也可以不存在） rank（58 是排名第几的元素）、select（排名第10的元素是谁） 在有些情况下，我们须要支持重复元素的二分搜索树。 二分搜索树的局限性二分搜索树可能会退化成链表。而通过对二分搜索树的时间复杂度分析，二分搜索树的查找过程是跟其高度有关的。 为了解决此问题，可以改造二叉树的实现，使得其无法退化成链表—–平衡二叉树，它有左右两棵子树，并且其高度差不会超过1，因此可以保证其高度一定是 logn 级别的，此概念的经典实现就是红黑树。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
        <tag>二分搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之链表]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表什么是单链表单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的元素。它的数据是以结点来表示的，每个结点的构成：数据（类型为要存储的数据的类型） + 指针，数据就是链表里具体要存储的东西，指针就是用来把每个节点都连接起来，使它们形成一个链状。 单链表的结构12345678910111213141516171819202122232425262728293031323334353637383940414243public class LinkedList&lt;E&gt; &#123; //数据存储在节点中（内部类） private class Node&#123; public E e; public Node next; public Node(E e, Node next)&#123; this.e = e; this.next = next; &#125; public Node(E e)&#123; this(e, null); &#125; public Node()&#123; this(null, null); &#125; @Override public String toString()&#123; return e.toString(); &#125; &#125; //这里用的是虚拟头节点，不存储数据，便于操作在头部删除和添加元素 private Node dummyHead; private int size; public LinkedList()&#123; dummyHead = new Node(); size = 0; &#125; // 获取链表中的元素个数 public int getSize()&#123; return size; &#125; // 返回链表是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 单链表的常用操作添加元素操作思想：找到要添加节点的前一个节点 Node node = new Node(e,null); node.next = prev.next; prev.next = node; 1234567891011121314151617181920212223// 在链表的index(0-based)位置添加新的元素epublic void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Illegal index."); Node prev = dummyHead; for(int i = 0 ; i &lt; index ; i ++) prev = prev.next; prev.next = new Node(e, prev.next); size ++;&#125;// 在链表头添加新的元素epublic void addFirst(E e)&#123; add(0, e);&#125;// 在链表末尾添加新的元素epublic void addLast(E e)&#123; add(size, e);&#125; 查询元素操作1234567891011121314151617181920212223242526272829303132// 获得链表的第index(0-based)个位置的元素public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Illegal index."); Node cur = dummyHead.next; for(int i = 0 ; i &lt; index ; i ++) cur = cur.next; return cur.e;&#125;// 获得链表的第一个元素public E getFirst()&#123; return get(0);&#125;// 获得链表的最后一个元素public E getLast()&#123; return get(size - 1);&#125;// 查找链表中是否有元素epublic boolean contains(E e)&#123; Node cur = dummyHead.next; while(cur != null)&#123; if(cur.e.equals(e)) return true; cur = cur.next; &#125; return false;&#125; 修改元素操作12345678910// 修改链表的第index(0-based)个位置的元素为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Illegal index."); Node cur = dummyHead.next; for(int i = 0 ; i &lt; index ; i ++) cur = cur.next; cur.e = e;&#125; 删除元素操作思想：找到要删除的节点的前一个节点 Node delNode = prev.next; prev.next = delNode.next delNode.next = null 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 从链表中删除index(0-based)位置的元素, 返回删除的元素public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); Node prev = dummyHead; for(int i = 0 ; i &lt; index ; i ++) prev = prev.next; Node retNode = prev.next; prev.next = retNode.next; retNode.next = null; size --; return retNode.e;&#125;// 从链表中删除第一个元素, 返回删除的元素public E removeFirst()&#123; return remove(0);&#125;// 从链表中删除最后一个元素, 返回删除的元素public E removeLast()&#123; return remove(size - 1);&#125;// 从链表中删除元素epublic void removeElement(E e)&#123; Node prev = dummyHead; while(prev.next != null)&#123; if(prev.next.e.equals(e)) break; prev = prev.next; &#125; if(prev.next != null)&#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size --; &#125;&#125; 单链表的时间复杂度分析添加操作：O(n) addLast(e)：O(n) addFirst(e)：O(1) add(index,e)：O(n/2) 删除操作：O(n) removeLast(e)：O(n) removeFirst(e)：O(1) remove(index,e)：O(n/2) 修改操作：O(n) set(index,e)：O(n) 查找操作：O(n) get(index)：O(n) contains(e)：O(n) 数组和链表的比较数组：优点：使用方便，查询效率比链表高，内存为一连续的区域。 缺点：大小固定，不适合动态存储，不方便动态添加。 动态数组优点：查找方便，适合随机查询。（查询快） 缺点：插入，删除操作不方便，因为插入，删除操作会导致大量元素的移动。 链表优点：真正的动态，不需要处理固定容量的问题。插入，删除方便，不会导致元素的移动，因为元素增减，只需要调整指针。 缺点：丧失了随机访问的能力（查询慢）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之动态数组]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组数组的特点优点： 按照索引查询数据元素速度快 能存储大量数据 按照索引遍历数组方便 缺点： 根据内容查找元素速度慢 数组的大小一经确定不能改变（数组的局限性） 数组只能存储一种类型的数据 增加，删除元素效率慢 未封装任何方法，所有操作都需要用户自己定义 12345678910111213141516171819202122232425262728293031public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 动态数组使得数组的容量是可以伸缩的。 实现动态数组的思路 定义一个新的容量newCapacity，以新容量开辟一个新数组newData 遍历原数组data的元素，赋值到新数组newData中 将原数组的指针指向新数组 12345678// 将数组空间的容量变成newCapacity大小private void resize(int newCapacity)&#123;E[] newData = (E[])new Object[newCapacity];for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData;&#125; 动态数组的常见操作添加元素操作1234567891011121314151617181920212223242526// 在index索引的位置插入一个新元素epublic void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length);//扩充数组的容量 for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++;&#125;// 向所有元素后添加一个新元素public void addLast(E e)&#123; add(size, e);&#125;// 在所有元素前添加一个新元素public void addFirst(E e)&#123; add(0, e);&#125; 删除元素操作1234567891011121314151617181920212223242526272829303132// 从数组中删除index位置的元素, 返回删除的元素public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0)//为何要如此判断，下面有分析 resize(data.length / 2); return ret;&#125;// 从数组中删除第一个元素, 返回删除的元素public E removeFirst()&#123; return remove(0);&#125;// 从数组中删除最后一个元素, 返回删除的元素public E removeLast()&#123; return remove(size - 1);&#125;// 从数组中删除元素epublic void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index);&#125; 更改元素操作123456// 修改index索引位置的元素为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e;&#125; 查询元素操作123456789101112131415161718192021222324// 获取index索引位置的元素public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index];&#125;// 查找数组中是否有元素epublic boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false;&#125;// 查找数组中元素e所在的索引，如果不存在元素e，则返回-1public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1;&#125; 动态数组时间复杂度分析添加元素操作：O(n) addLast(e)：O(1) addFirst(e)：O(n) add(index,e)：O(n/2) 删除元素操作：O(n) removeLast(e)：O(1) removeFirst(e)：O(n) remove(index,e)：O(n/2) 修改元素操作：已知索引：O(1)；未知索引：O(n) set(index,e)：O(1) 查找元素操作：已知索引O(1)；未知索引O(n) get(index)：O(1) contains(e):：O(n) find(e)：O(n) resize()时间复杂度分析 resize()：O(n) 从均摊复杂度的角度看addLast操作和removeLast操作 假设capacity=n，n+1次addLast，触发resize，而resize操作了n次，所以总共进行2n+1次基本操作，使用均摊复杂度均摊计算，每次addLast操作，进行2次基本操作，时间复杂度为O(1)。同理，我们看removeLast操作，均摊复杂度后的时间复杂度也为O(1). 防止复杂度震荡 出现复杂度震荡的问题描述： 假设现在我们有一个数组，容量是n，并且装满了元素。这时候，我想添加一个元素，显然是需要进行扩容，容量变为2n，耗时O(n)的时间。但是此时，我又删除了一个元素触发了缩容操作，耗时O(n)的时间。当我们每次触发缩容或扩容操作，都会耗费O(n)额复杂度，那么这便是复杂度的震荡。 分析原因：在特殊情况下，我们频繁的添加和删减操作，导致过于着急的去扩容或缩容。 解决方案： 可以采用一种相对懒惰(Lazy机制)的策略。 比如说，一个满的数组，容量n，添加元素需要进行扩容，容量变为2n。但在这时，在进行删除元素后，不立即进行缩容操作，而是再等等。如果后面一直有删除操作的话，删除到整个数组容积的1/4，再触发缩容操作。缩容数组的1/2，而不是直接缩容到1/4。此时，数组中存在1/4的元素，还预留了1/4的空间。通过这样的策略，防止了复杂度的震荡，从而有效的提升整体的性能。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
        <tag>动态数组</tag>
      </tags>
  </entry>
</search>
