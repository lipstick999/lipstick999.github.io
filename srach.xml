<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP协议详解]]></title>
    <url>%2F2019%2F06%2F24%2FHTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[关于HTTP协议的，这一篇就够了HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP协议的特点HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 HTTP协议的主要特点可概括如下： 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 支持B/S及C/S模式。 URI和URL的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。HTTP使用统一资源标识符（URI）来传输数据和建立连接。 Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的。 URI一般由三部组成： 访问资源的命名机制 存放资源的主机名 资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成： 协议(或称为服务方式) 存有该资源的主机IP地址(有时也包括端口号) 主机资源的具体地址。如目录和文件名等 以下面这个URL为例，介绍下普通URL的各部分组成： http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分： 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。 区别：URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。 相反的是，URL类可以打开一个到达资源的流。 请求消息Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 响应消息Response状态码HTTP工作原理GET和POST请求的区别]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125; // 在index索引的位置插入一个新元素e public void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length); for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++; &#125; // 向所有元素后添加一个新元素 public void addLast(E e)&#123; add(size, e); &#125; // 在所有元素前添加一个新元素 public void addFirst(E e)&#123; add(0, e); &#125; // 获取index索引位置的元素 public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index]; &#125; // 修改index索引位置的元素为e public void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e; &#125; // 查找数组中是否有元素e public boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false; &#125; // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1 public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1; &#125; // 从数组中删除index位置的元素, 返回删除的元素 public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0) resize(data.length / 2); return ret; &#125; // 从数组中删除第一个元素, 返回删除的元素 public E removeFirst()&#123; return remove(0); &#125; // 从数组中删除最后一个元素, 返回删除的元素 public E removeLast()&#123; return remove(size - 1); &#125; // 从数组中删除元素e public void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d , capacity = %d\n", size, data.length)); res.append('['); for(int i = 0 ; i &lt; size ; i ++)&#123; res.append(data[i]); if(i != size - 1) res.append(", "); &#125; res.append(']'); return res.toString(); &#125; // 将数组空间的容量变成newCapacity大小 private void resize(int newCapacity)&#123; E[] newData = (E[])new Object[newCapacity]; for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData; &#125;&#125; 分析动态数组的时间复杂度 添加操作：O(n) addLast(e)：O(1) addFirst(e)：O(n) add(index,e)：O(n/2) 删除操作：O(n) removeLast(e)：O(1) removeFirst(e)：O(n) remove(index,e)：O(n/2) 修改操作：已知索引O(1)；未知索引O(n) set(index,e)：O(1) 查找操作：已知索引O(1)；未知索引O(n) get(index)：O(1) contains(e):：O(n) find(e)：O(n) resize的时间复杂度分析 假设capacity=n，n+1次addLast，触发resize，总共进行2n+1次基本操作，使用均摊复杂度均摊计算，每次addLast操作，进行2次基本操作，时间复杂度为O(1) 复杂度震荡 出现问题的原因是removeLast时resize过于着急 我们可以当size==capacity/4时，才将capacity减半。]]></content>
      <categories>
        <category>数据结构</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F06%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[动态数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125; // 在index索引的位置插入一个新元素e public void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length); for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++; &#125; // 向所有元素后添加一个新元素 public void addLast(E e)&#123; add(size, e); &#125; // 在所有元素前添加一个新元素 public void addFirst(E e)&#123; add(0, e); &#125; // 获取index索引位置的元素 public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index]; &#125; // 修改index索引位置的元素为e public void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e; &#125; // 查找数组中是否有元素e public boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false; &#125; // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1 public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1; &#125; // 从数组中删除index位置的元素, 返回删除的元素 public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0) resize(data.length / 2); return ret; &#125; // 从数组中删除第一个元素, 返回删除的元素 public E removeFirst()&#123; return remove(0); &#125; // 从数组中删除最后一个元素, 返回删除的元素 public E removeLast()&#123; return remove(size - 1); &#125; // 从数组中删除元素e public void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d , capacity = %d\n", size, data.length)); res.append('['); for(int i = 0 ; i &lt; size ; i ++)&#123; res.append(data[i]); if(i != size - 1) res.append(", "); &#125; res.append(']'); return res.toString(); &#125; // 将数组空间的容量变成newCapacity大小 private void resize(int newCapacity)&#123; E[] newData = (E[])new Object[newCapacity]; for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData; &#125;&#125; 分析动态数组的时间复杂度 添加操作：O(n) addLast(e)：O(1) addFirst(e)：O(n) add(index,e)：O(n/2) 删除操作：O(n) removeLast(e)：O(1) removeFirst(e)：O(n) remove(index,e)：O(n/2) 修改操作：已知索引O(1)；未知索引O(n) set(index,e)：O(1) 查找操作：已知索引O(1)；未知索引O(n) get(index)：O(1) contains(e):：O(n) find(e)：O(n) resize的时间复杂度分析 假设capacity=n，n+1次addLast，触发resize，总共进行2n+1次基本操作，使用均摊复杂度均摊计算，每次addLast操作，进行2次基本操作，时间复杂度为O(1) 复杂度震荡 出现问题的原因是removeLast时resize过于着急 我们可以当size==capacity/4时，才将capacity减半。]]></content>
      <categories>
        <category>数据结构</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态数组</tag>
      </tags>
  </entry>
</search>
