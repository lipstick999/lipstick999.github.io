<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构之链表]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表什么是单链表单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的元素。它的数据是以结点来表示的，每个结点的构成：数据（类型为要存储的数据的类型） + 指针，数据就是链表里具体要存储的东西，指针就是用来把每个节点都连接起来，使它们形成一个链状。 单链表的结构12345678910111213141516171819202122232425262728293031323334353637383940414243public class LinkedList&lt;E&gt; &#123; //数据存储在节点中（内部类） private class Node&#123; public E e; public Node next; public Node(E e, Node next)&#123; this.e = e; this.next = next; &#125; public Node(E e)&#123; this(e, null); &#125; public Node()&#123; this(null, null); &#125; @Override public String toString()&#123; return e.toString(); &#125; &#125; //这里用的是虚拟头节点，不存储数据，便于操作在头部删除和添加元素 private Node dummyHead; private int size; public LinkedList()&#123; dummyHead = new Node(); size = 0; &#125; // 获取链表中的元素个数 public int getSize()&#123; return size; &#125; // 返回链表是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 单链表的常用操作添加元素操作思想：找到要添加节点的前一个节点 Node node = new Node(e,null); node.next = prev.next; prev.next = node; 1234567891011121314151617181920212223// 在链表的index(0-based)位置添加新的元素epublic void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Illegal index."); Node prev = dummyHead; for(int i = 0 ; i &lt; index ; i ++) prev = prev.next; prev.next = new Node(e, prev.next); size ++;&#125;// 在链表头添加新的元素epublic void addFirst(E e)&#123; add(0, e);&#125;// 在链表末尾添加新的元素epublic void addLast(E e)&#123; add(size, e);&#125; 查询元素操作1234567891011121314151617181920212223242526272829303132// 获得链表的第index(0-based)个位置的元素public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Illegal index."); Node cur = dummyHead.next; for(int i = 0 ; i &lt; index ; i ++) cur = cur.next; return cur.e;&#125;// 获得链表的第一个元素public E getFirst()&#123; return get(0);&#125;// 获得链表的最后一个元素public E getLast()&#123; return get(size - 1);&#125;// 查找链表中是否有元素epublic boolean contains(E e)&#123; Node cur = dummyHead.next; while(cur != null)&#123; if(cur.e.equals(e)) return true; cur = cur.next; &#125; return false;&#125; 修改元素操作12345678910// 修改链表的第index(0-based)个位置的元素为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Illegal index."); Node cur = dummyHead.next; for(int i = 0 ; i &lt; index ; i ++) cur = cur.next; cur.e = e;&#125; 删除元素操作思想：找到要删除的节点的前一个节点 Node delNode = prev.next; prev.next = delNode.next delNode.next = null 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 从链表中删除index(0-based)位置的元素, 返回删除的元素public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); Node prev = dummyHead; for(int i = 0 ; i &lt; index ; i ++) prev = prev.next; Node retNode = prev.next; prev.next = retNode.next; retNode.next = null; size --; return retNode.e;&#125;// 从链表中删除第一个元素, 返回删除的元素public E removeFirst()&#123; return remove(0);&#125;// 从链表中删除最后一个元素, 返回删除的元素public E removeLast()&#123; return remove(size - 1);&#125;// 从链表中删除元素epublic void removeElement(E e)&#123; Node prev = dummyHead; while(prev.next != null)&#123; if(prev.next.e.equals(e)) break; prev = prev.next; &#125; if(prev.next != null)&#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size --; &#125;&#125; 单链表的时间复杂度分析添加操作：O(n) addLast(e)：O(n) addFirst(e)：O(1) add(index,e)：O(n/2) 删除操作：O(n) removeLast(e)：O(n) removeFirst(e)：O(1) remove(index,e)：O(n/2) 修改操作：O(n) set(index,e)：O(n) 查找操作：O(n) get(index)：O(n) contains(e)：O(n) 数组和链表的比较数组：优点：使用方便，查询效率比链表高，内存为一连续的区域。 缺点：大小固定，不适合动态存储，不方便动态添加。 动态数组优点：查找方便，适合随机查询。（查询快） 缺点：插入，删除操作不方便，因为插入，删除操作会导致大量元素的移动。 链表优点：真正的动态，不需要处理固定容量的问题。插入，删除方便，不会导致元素的移动，因为元素增减，只需要调整指针。 缺点：丧失了随机访问的能力（查询慢）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之动态数组]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组数组的特点优点： 按照索引查询数据元素速度快 能存储大量数据 按照索引遍历数组方便 缺点： 根据内容查找元素速度慢 数组的大小一经确定不能改变（数组的局限性） 数组只能存储一种类型的数据 增加，删除元素效率慢 未封装任何方法，所有操作都需要用户自己定义 12345678910111213141516171819202122232425262728293031public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 动态数组使得数组的容量是可以伸缩的。 实现动态数组的思路 定义一个新的容量newCapacity，以新容量开辟一个新数组newData 遍历原数组data的元素，赋值到新数组newData中 将原数组的指针指向新数组 12345678// 将数组空间的容量变成newCapacity大小private void resize(int newCapacity)&#123;E[] newData = (E[])new Object[newCapacity];for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData;&#125; 动态数组的常见操作添加元素操作1234567891011121314151617181920212223242526// 在index索引的位置插入一个新元素epublic void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length);//扩充数组的容量 for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++;&#125;// 向所有元素后添加一个新元素public void addLast(E e)&#123; add(size, e);&#125;// 在所有元素前添加一个新元素public void addFirst(E e)&#123; add(0, e);&#125; 删除元素操作1234567891011121314151617181920212223242526272829303132// 从数组中删除index位置的元素, 返回删除的元素public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0)//为何要如此判断，下面有分析 resize(data.length / 2); return ret;&#125;// 从数组中删除第一个元素, 返回删除的元素public E removeFirst()&#123; return remove(0);&#125;// 从数组中删除最后一个元素, 返回删除的元素public E removeLast()&#123; return remove(size - 1);&#125;// 从数组中删除元素epublic void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index);&#125; 更改元素操作123456// 修改index索引位置的元素为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e;&#125; 查询元素操作123456789101112131415161718192021222324// 获取index索引位置的元素public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index];&#125;// 查找数组中是否有元素epublic boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false;&#125;// 查找数组中元素e所在的索引，如果不存在元素e，则返回-1public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1;&#125; 动态数组时间复杂度分析添加元素操作：O(n) addLast(e)：O(1) addFirst(e)：O(n) add(index,e)：O(n/2) 删除元素操作：O(n) removeLast(e)：O(1) removeFirst(e)：O(n) remove(index,e)：O(n/2) 修改元素操作：已知索引：O(1)；未知索引：O(n) set(index,e)：O(1) 查找元素操作：已知索引O(1)；未知索引O(n) get(index)：O(1) contains(e):：O(n) find(e)：O(n) resize()时间复杂度分析 resize()：O(n) 从均摊复杂度的角度看addLast操作和removeLast操作 假设capacity=n，n+1次addLast，触发resize，而resize操作了n次，所以总共进行2n+1次基本操作，使用均摊复杂度均摊计算，每次addLast操作，进行2次基本操作，时间复杂度为O(1)。同理，我们看removeLast操作，均摊复杂度后的时间复杂度也为O(1). 防止复杂度震荡 出现复杂度震荡的问题描述： 假设现在我们有一个数组，容量是n，并且装满了元素。这时候，我想添加一个元素，显然是需要进行扩容，容量变为2n，耗时O(n)的时间。但是此时，我又删除了一个元素触发了缩容操作，耗时O(n)的时间。当我们每次触发缩容或扩容操作，都会耗费O(n)额复杂度，那么这便是复杂度的震荡。 分析原因：在特殊情况下，我们频繁的添加和删减操作，导致过于着急的去扩容或缩容。 解决方案： 可以采用一种相对懒惰(Lazy机制)的策略。 比如说，一个满的数组，容量n，添加元素需要进行扩容，容量变为2n。但在这时，在进行删除元素后，不立即进行缩容操作，而是再等等。如果后面一直有删除操作的话，删除到整个数组容积的1/4，再触发缩容操作。缩容数组的1/2，而不是直接缩容到1/4。此时，数组中存在1/4的元素，还预留了1/4的空间。通过这样的策略，防止了复杂度的震荡，从而有效的提升整体的性能。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>动态数组</tag>
        <tag>java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
